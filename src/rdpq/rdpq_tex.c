/**
 * @file rdpq_tex.c
 * @brief RDP Command queue: texture loading
 * @ingroup rdp
 */

#define _GNU_SOURCE
#include "rdpq.h"
#include "rdpq_tri.h"
#include "rdpq_quad.h"
#include "rdpq_tex.h"
#include "utils.h"
#include <math.h>

/** @brief Address in TMEM where the palettes must be loaded */
#define TMEM_PALETTE_ADDR   0x800


/** @brief Precomputes everything required for loading the rect (s0,t0)-(s1,t1) 
 * 
 * This function prepares for a new TMEM load for the specified rectangle. Since it is very
 * common to invoke multiple different rects with similar width and/or height, this function
 * tries to compute only what needs to be done with respect the previous load. Specifically:
 * 
 * * If the width of the rectangle changed, we need to compute the TMEM pitch, and verifies
 *   whether we can use LOAD_BLOCK. We can check basic constaints with the width, but there
 *   will be a maximum number of lines that can be transferred with LOAD_BLOCK.
 * * If the height of the rectangle changed, we can calculate the total number of texels
 *   and complete the LOAD_BLOCK calculation by verifying that the height is within the
 *   maximum allowed range.
 */
static int texload_set_rect(tex_loader_t *tload, int s0, int t0, int s1, int t1)
{
    tex_format_t fmt = surface_get_format(tload->tex);
    if (TEX_FORMAT_BITDEPTH(fmt) == 4) {
        s0 &= ~1; s1 = (s1+1) & ~1;
    }

    int width = s1 - s0;
    int height = t1 - t0;

    if (width != tload->rect.width || height != tload->rect.height) {
        if (width != tload->rect.width) {
            // Calculate he new pitch in TMEM (in bytes). Notice that RGBA32 is special
            // as texture data is split in two halves, so the pitch can be halved.
            int pitch_shift = fmt == FMT_RGBA32 ? 1 : 0;
            int stride_mask = fmt == FMT_RGBA32 ? 15 : 7;
            tload->rect.tmem_pitch = ROUND_UP(TEX_FORMAT_PIX2BYTES(fmt, width) >> pitch_shift, 8);

            // Verify whether we can use LOAD_BLOCK. The conditions we can verify just by looking at the
            // width are:
            //   * User is not requesting usage of tile 7 (RDPQ_TILE_INTERNAL). We need one scratch tile
            //     for LOAD_BLOCK, so if the user is requesting tile 7, we can't use LOAD_BLOCK.
            //   * The rectangle to load cover the whole texture horizontally, and the texture does not
            //     contain extraneous data at the end of each line.
            //   * The width of the texture is a multiple of 8 bytes (or 16 bytes, in case of RGBA32).
            bool can_load_block_width =
                tload->tile != RDPQ_TILE_INTERNAL && 
                TEX_FORMAT_PIX2BYTES(fmt, width) == tload->tex->stride &&
                (tload->tex->stride & stride_mask) == 0;

            if (can_load_block_width) {
                // If the requirements are satisfied, we need to compute the maximum number of lines
                // that can be loaded with LOAD_BLOCK. In fact, RDP uses fixed point precision;
                // the DXT parameter in the LOAD_BLOCK command is a 1.10 fixed point number, so
                // there is a precision error after a certain number of lines that can cause artifacts.

                // We precomputed a table that stores the maximum number of lines for each possible width.
                // (actually, for each possible pitch / 8, given that the pitch must be a multiple of 8).
                // This table was generated by the following Python code:
                //
                //            # (thanks to glank for describing a neat way to find the error in dxt per line)
                //            words_per_line = line_bytes // 8
                //            dxt = (1 << 11) / words_per_line
                //            # dxt is rounded up, so the error is 1 - the fractional part of dxt
                //            err = 1.0 - math.modf(dxt)[0]
                //            # the error per line is the error per 64-bit word * the number of words
                //            err_per_line = words_per_line * err
                //            # the maximum number of lines before this becomes an issue is
                //            max_lines = math.floor(dxt / err_per_line)
                //
                // The table doesn't contain the first 11 entries as they are all unlimited (that is, the error does not happen
                // within the 4K TMEM size).
                static const uint8_t block_max_lines_table[] = { 20, 42, 26, 14, 19, 32, 13, 28, 26, 8, 9, 4, 4, 5, 20, 13, 18, 3, 6, 3, 2, 16, 2, 2, 3, 14, 2, 13, 2, 1, 12, 4, 2, 2, 2, 2, 2, 2, 4, 10, 0, 1, 2, 9, 0, 1, 8, 0, 2, 0, 1, 0, 1, 8, 0, 0, 1, 0, 1, 0, 2, 0, 0, 1, 0, 6, 0, 0, 4, 0, 0, 6, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 
                int words = tload->rect.tmem_pitch / 8;
                if (words >= 11)
                    tload->rect.block_max_lines = block_max_lines_table[words - 11];
                else
                    tload->rect.block_max_lines = 4096;  // arbitrary high number, it will be limited by TMEM size anyway
            } else {
                tload->rect.block_max_lines = 0;
            }
            
            // Invalidate the current load mode. This will force the next load_tile function to reissue
            // the RDP configuration.
            tload->load_mode = TEX_LOAD_UNKNOWN;
        }

        // If the height changed, complete filling the rect structure,
        // and calculate whether we can really use LOAD_BLOCK or not.
        int tmem_size = (fmt == FMT_RGBA32 || fmt == FMT_CI4 || fmt == FMT_CI8) ? 2048 : 4096;
        assertf(height * tload->rect.tmem_pitch <= tmem_size,
            "A rectangle of size %dx%d format %s is too big to fit in TMEM", width, height, tex_format_name(fmt));
        tload->rect.width = width;
        tload->rect.height = height;
        tload->rect.num_texels = width * height;
        tload->rect.can_load_block = height <= tload->rect.block_max_lines;
    }
    return tload->rect.tmem_pitch * height;
}

int tex_loader_load(tex_loader_t *tload, int s0, int t0, int s1, int t1)
{
    int mem = texload_set_rect(tload, s0, t0, s1, t1);
    if (tload->rect.can_load_block && (t0 & 1) == 0)
        tload->load_block(tload, s0, t0, s1, t1);
    else
        tload->load_tile(tload, s0, t0, s1, t1);
    return mem;
}

static void tex_loader_set_tmem_addr(tex_loader_t *tload, int tmem_addr)
{
    tload->tmem_addr = tmem_addr;
    tload->load_mode = TEX_LOAD_UNKNOWN;
}

static void tex_loader_set_tlut(tex_loader_t *tload, int tlut)
{
    tload->tlut = tlut;
    tload->load_mode = TEX_LOAD_UNKNOWN;
}

static int texload_calc_max_height(tex_loader_t *tload, int width)
{
    texload_set_rect(tload, 0, 0, width, 1);

    tex_format_t fmt = surface_get_format(tload->tex);
    int tmem_size = (fmt == FMT_RGBA32 || fmt == FMT_CI4 || fmt == FMT_CI8) ? 2048 : 4096;
    return tmem_size / tload->rect.tmem_pitch;
}

static void texload_block_4bpp(tex_loader_t *tload, int s0, int t0, int s1, int t1)
{
    if (tload->load_mode != TEX_LOAD_BLOCK) {
        // Use LOAD_BLOCK if we are uploading a full texture. Notice the weirdness of LOAD_BLOCK:
        // * SET_TILE must be configured with tmem_pitch=0, as that is weirdly used as the number of
        //   texels to skip per line, which we don't need.
        assertf(tload->tex->width % 4 == 0, "Internal Error: invalid width for LOAD_BLOCK (%d)", tload->tex->width);
        rdpq_set_texture_image_raw(0, PhysicalAddr(tload->tex->buffer), FMT_RGBA16, tload->tex->width/4, tload->tex->height);
        rdpq_set_tile(RDPQ_TILE_INTERNAL, FMT_RGBA16, tload->tmem_addr, 0, 0);
        rdpq_set_tile(tload->tile, surface_get_format(tload->tex), tload->tmem_addr, tload->rect.tmem_pitch, tload->tlut);
        tload->load_mode = TEX_LOAD_BLOCK;
    }

    s0 &= ~1; s1 = (s1+1) & ~1;
    rdpq_load_block(RDPQ_TILE_INTERNAL, s0/2, t0, tload->rect.num_texels/4, tload->rect.tmem_pitch);
    rdpq_set_tile_size(tload->tile, s0, t0, s1, t1);
}

static void texload_tile_4bpp(tex_loader_t *tload, int s0, int t0, int s1, int t1)
{
    if (tload->load_mode != TEX_LOAD_TILE) {
        rdpq_set_texture_image_raw(0, PhysicalAddr(tload->tex->buffer), FMT_CI8, tload->tex->stride, tload->tex->height);
        rdpq_set_tile(RDPQ_TILE_INTERNAL, FMT_CI8, tload->tmem_addr, tload->rect.tmem_pitch, 0);
        rdpq_set_tile(tload->tile, surface_get_format(tload->tex), tload->tmem_addr, tload->rect.tmem_pitch, tload->tlut);
    }

    s0 &= ~1; s1 = (s1+1) & ~1;
    rdpq_load_tile(RDPQ_TILE_INTERNAL, s0/2, t0, s1/2, t1);
    rdpq_set_tile_size(tload->tile, s0, t0, s1, t1);
}

static void texload_block(tex_loader_t *tload, int s0, int t0, int s1, int t1)
{
    tex_format_t fmt = surface_get_format(tload->tex);

    if (tload->load_mode != TEX_LOAD_BLOCK) {
        // Use LOAD_BLOCK if we are uploading a full texture. Notice the weirdness of LOAD_BLOCK:
        // * SET_TILE must be configured with tmem_pitch=0, as that is weirdly used as the number of
        //   texels to skip per line, which we don't need.
        rdpq_set_texture_image_raw(0, PhysicalAddr(tload->tex->buffer), fmt, tload->tex->width, tload->tex->height);
        rdpq_set_tile(RDPQ_TILE_INTERNAL, fmt, tload->tmem_addr, 0, 0);
        rdpq_set_tile(tload->tile, fmt, tload->tmem_addr, tload->rect.tmem_pitch, tload->tlut);
        tload->load_mode = TEX_LOAD_BLOCK;
    }

    rdpq_load_block(RDPQ_TILE_INTERNAL, s0, t0, tload->rect.num_texels, (fmt == FMT_RGBA32) ? tload->rect.tmem_pitch*2 : tload->rect.tmem_pitch);
    rdpq_set_tile_size(tload->tile, s0, t0, s1, t1);
}

static void texload_tile(tex_loader_t *tload, int s0, int t0, int s1, int t1)
{
    tex_format_t fmt = surface_get_format(tload->tex);

    if (tload->load_mode != TEX_LOAD_TILE) {
        rdpq_set_texture_image(tload->tex);
        rdpq_set_tile(tload->tile, fmt, tload->tmem_addr, tload->rect.tmem_pitch, tload->tlut);
        tload->load_mode = TEX_LOAD_TILE;
    }

    rdpq_load_tile(tload->tile, s0, t0, s1, t1);
}

tex_loader_t tex_loader_init(rdpq_tile_t tile, const surface_t *tex) {
    bool is_4bpp = TEX_FORMAT_BITDEPTH(surface_get_format(tex)) == 4;
    return (tex_loader_t){
        .tex = tex,
        .tile = tile,
        .load_block = is_4bpp ? texload_block_4bpp : texload_block,
        .load_tile = is_4bpp ? texload_tile_4bpp : texload_tile,
    };
}

int rdpq_tex_load_sub_ci4(rdpq_tile_t tile, surface_t *tex, int tmem_addr, int tlut, int s0, int t0, int s1, int t1)
{
    tex_loader_t tload = tex_loader_init(tile, tex);
    tex_loader_set_tlut(&tload, tlut);
    tex_loader_set_tmem_addr(&tload, tmem_addr);
    return tex_loader_load(&tload, s0, t0, s1, t1);
#   
}

int rdpq_tex_load_ci4(rdpq_tile_t tile, surface_t *tex, int tmem_addr, int tlut)
{
    return rdpq_tex_load_sub_ci4(tile, tex, tmem_addr, tlut, 0, 0, tex->width, tex->height);
}

int rdpq_tex_load_sub(rdpq_tile_t tile, surface_t *tex, int tmem_addr, int s0, int t0, int s1, int t1)
{
    tex_loader_t tload = tex_loader_init(tile, tex);
    tex_loader_set_tmem_addr(&tload, tmem_addr);
    return tex_loader_load(&tload, s0, t0, s1, t1);
}

int rdpq_tex_load(rdpq_tile_t tile, surface_t *tex, int tmem_addr)
{
    return rdpq_tex_load_sub(tile, tex, tmem_addr, 0, 0, tex->width, tex->height);
}

/**
 * @brief Helper function to draw a large surface that doesn't fit in TMEM.
 * 
 * This function analyzes the surface, finds the optimal splitting strategy to
 * divided into rectangles that fit TMEM, and then go through them one of by one,
 * loading them into TMEM and drawing them.
 * 
 * The actual drawing is done by the caller, through the draw_cb function. This
 * function will just call it with the information on the current rectangle
 * within the original surface.
 * 
 * @param tile          Hint of the tile to use. Note that this function is free to use
 *                      other tiles to perform its job.
 * @param tex           Surface to draw
 * @param draw_cb       Callback function to draw rectangle by rectangle. It will be called
 *                      with the tile to use for drawing, and the rectangle of the original
 *                      surface that has been loaded into TMEM.
 * @param filtering     Enable texture filtering workaround
 */
static void tex_draw_split(rdpq_tile_t tile, const surface_t *tex, int s0, int t0, int s1, int t1, 
    void (*draw_cb)(rdpq_tile_t tile, int s0, int t0, int s1, int t1), bool filtering)
{
    // The most efficient way to split a large surface is to load it in horizontal strips,
    // whose height maximizes TMEM usage. The last strip might be smaller than the others.

    // Initial configuration of texloader
    tex_loader_t tload = tex_loader_init(tile, tex);

    // Calculate the optimal height for a strip, based on strips of maximum length.
    int tile_h = texload_calc_max_height(&tload, tex->width);
    
    // Go through the surface
    while (t0 < t1) 
    {
        // Calculate the height of the current strip
        int tm = filtering ? MAX(t0 - 1, 0) : t0;
        int tn = MIN(tm + tile_h, t1);

        // Load the current strip
        tex_loader_load(&tload, s0, tm, s1, tn);

        // Call the draw callback for this strip
        int tx = (!filtering || tn == t1) ? tn : tn - 1;
        draw_cb(tile, s0, t0, s1, tx);

        // Move to the next strip
        t0 = tx;
    }
}

__attribute__((noinline))
static void tex_xblit_norotate_noscale(const surface_t *surf, float x0, float y0, const rdpq_blitparms_t *parms)
{
    rdpq_tile_t tile = parms->tile;
    int src_width = parms->width ? parms->width : surf->width;
    int src_height = parms->height ? parms->height : surf->height;
    int s0 = parms->s0;
    int t0 = parms->t0;
    int cx = parms->cx + s0;
    int cy = parms->cy + t0;
    bool flip_x = parms->flip_x;
    bool flip_y = parms->flip_y;

    void draw_cb(rdpq_tile_t tile, int s0, int t0, int s1, int t1)
    {
        int ks0 = s0, kt0 = t0, ks1 = s1, kt1 = t1;
        if (flip_x) { ks0 = src_width - s1; ks1 = src_width - s0; s0 = s1-1; }
        if (flip_y) { kt0 = src_height - t1; kt1 = src_height - t0; t0 = t1-1; }

        rdpq_texture_rectangle(tile, x0 + ks0 - cx, y0 + kt0 - cy, x0 + ks1 - cx, y0 + kt1 - cy, s0, t0);
    }

    tex_draw_split(tile, surf, s0, t0, s0 + src_width, t0 + src_height, draw_cb, parms->filtering);
}

__attribute__((noinline))
static void tex_xblit_norotate(const surface_t *surf, float x0, float y0, const rdpq_blitparms_t *parms)
{
    rdpq_tile_t tile = parms->tile;
    int src_width = parms->width ? parms->width : surf->width;
    int src_height = parms->height ? parms->height : surf->height;
    int s0 = parms->s0;
    int t0 = parms->t0;
    int cx = parms->cx + s0;
    int cy = parms->cy + t0;
    float scalex = parms->scale_x == 0 ? 1.0f : parms->scale_x;
    float scaley = parms->scale_y == 0 ? 1.0f : parms->scale_y;
    bool flip_x = (scalex < 0) ^ parms->flip_x;
    bool flip_y = (scaley < 0) ^ parms->flip_y;

    float mtx[3][2] = {
        { scalex, 0 },
        { 0, scaley },
        { x0 - cx * scalex,
          y0 - cy * scaley }
    };

    void draw_cb(rdpq_tile_t tile, int s0, int t0, int s1, int t1)
    {
        int ks0 = s0, kt0 = t0, ks1 = s1, kt1 = t1;

        if (flip_x) { ks0 = src_width - s1; ks1 = src_width - s0; s0 = s1-1; }
        if (flip_y) { kt0 = src_height - t1; kt1 = src_height - t0; t0 = t1-1; }

        float k0x = mtx[0][0] * ks0 + mtx[1][0] * kt0 + mtx[2][0];
        float k0y = mtx[0][1] * ks0 + mtx[1][1] * kt0 + mtx[2][1];
        float k2x = mtx[0][0] * ks1 + mtx[1][0] * kt1 + mtx[2][0];
        float k2y = mtx[0][1] * ks1 + mtx[1][1] * kt1 + mtx[2][1];

        rdpq_texture_rectangle_scaled(tile, k0x, k0y, k2x, k2y, s0, t0, s1, t1);
    }

    tex_draw_split(tile, surf, s0, t0, s0 + src_width, t0 + src_height, draw_cb, parms->filtering);
}

__attribute__((noinline))
static void tex_xblit(const surface_t *surf, float x0, float y0, const rdpq_blitparms_t *parms)
{
    rdpq_tile_t tile = parms->tile;
    int src_width = parms->width ? parms->width : surf->width;
    int src_height = parms->height ? parms->height : surf->height;
    int s0 = parms->s0;
    int t0 = parms->t0;
    int cx = parms->cx + s0;
    int cy = parms->cy + t0;
    int nx = parms->nx;
    int ny = parms->ny;
    float scalex = parms->scale_x == 0 ? 1.0f : parms->scale_x;
    float scaley = parms->scale_y == 0 ? 1.0f : parms->scale_y;

    float sin_theta, cos_theta; 
    sincosf(parms->theta, &sin_theta, &cos_theta);

    float mtx[3][2] = {
        { cos_theta * scalex, -sin_theta * scaley },
        { sin_theta * scalex, cos_theta * scaley },
        { x0 - cx * cos_theta * scalex - cy * sin_theta * scaley,
          y0 + cx * sin_theta * scalex - cy * cos_theta * scaley }
    };

    void draw_cb(rdpq_tile_t tile, int s0, int t0, int s1, int t1)
    {
        int ks0 = s0, kt0 = t0, ks1 = s1, kt1 = t1;

        if (parms->flip_x) { ks0 = src_width - ks0; ks1 = src_width - ks1; }
        if (parms->flip_y) { kt0 = src_height - kt0; kt1 = src_height - kt1; }

        float k0x = mtx[0][0] * ks0 + mtx[1][0] * kt0 + mtx[2][0];
        float k0y = mtx[0][1] * ks0 + mtx[1][1] * kt0 + mtx[2][1];
        float k2x = mtx[0][0] * ks1 + mtx[1][0] * kt1 + mtx[2][0];
        float k2y = mtx[0][1] * ks1 + mtx[1][1] * kt1 + mtx[2][1];
        float k1x = mtx[0][0] * ks1 + mtx[1][0] * kt0 + mtx[2][0];
        float k1y = mtx[0][1] * ks1 + mtx[1][1] * kt0 + mtx[2][1];
        float k3x = mtx[0][0] * ks0 + mtx[1][0] * kt1 + mtx[2][0];
        float k3y = mtx[0][1] * ks0 + mtx[1][1] * kt1 + mtx[2][1];

        float v0[5] = { k0x, k0y, s0, t0, 1.0f };
        float v1[5] = { k1x, k1y, s1, t0, 1.0f };
        float v2[5] = { k2x, k2y, s1, t1, 1.0f };
        float v3[5] = { k3x, k3y, s0, t1, 1.0f };
        rdpq_triangle(&TRIFMT_TEX, v0, v1, v2);
        rdpq_triangle(&TRIFMT_TEX, v0, v2, v3);
    }

    void draw_cb_multi_rot(rdpq_tile_t tile, int s0, int t0, int s1, int t1)
    {
        int ks0 = s0, kt0 = t0, ks1 = s1, kt1 = t1;
        if (parms->flip_x) { ks0 = src_width - ks0; ks1 = src_width - ks1; }
        if (parms->flip_y) { kt0 = src_height - kt0; kt1 = src_height - kt1; }

        assert(s1-s0 == src_width);

        for (int j=0; j<ny; j++) {
            int kkt0 = kt0 + j * src_height;
            int kkt1 = kt1 + j * src_height;

            // rdpq_triangle_strip_begin(&TRIFMT_TEX);

            float kks0 = ks0;
            float kks1 = ks1;
            for (int i=0; i<=nx; i++) {
                float k0x = mtx[0][0] * kks0 + mtx[1][0] * kkt0 + mtx[2][0];
                float k0y = mtx[0][1] * kks0 + mtx[1][1] * kkt0 + mtx[2][1];
                float k2x = mtx[0][0] * kks1 + mtx[1][0] * kkt1 + mtx[2][0];
                float k2y = mtx[0][1] * kks1 + mtx[1][1] * kkt1 + mtx[2][1];
                float k1x = mtx[0][0] * kks1 + mtx[1][0] * kkt0 + mtx[2][0];
                float k1y = mtx[0][1] * kks1 + mtx[1][1] * kkt0 + mtx[2][1];
                float k3x = mtx[0][0] * kks0 + mtx[1][0] * kkt1 + mtx[2][0];
                float k3y = mtx[0][1] * kks0 + mtx[1][1] * kkt1 + mtx[2][1];

                float v0[5] = { k0x, k0y, s0, t0, 1.0f };
                float v1[5] = { k1x, k1y, s1, t0, 1.0f };
                float v2[5] = { k2x, k2y, s1, t1, 1.0f };
                float v3[5] = { k3x, k3y, s0, t1, 1.0f };
                rdpq_triangle(&TRIFMT_TEX, v0, v1, v2);
                rdpq_triangle(&TRIFMT_TEX, v0, v2, v3);

                // rdpq_triangle_strip(v0);
                // rdpq_triangle_strip(v3);
                kks0 += src_width;
                kks1 += src_width;
            }
        }
    }

    if (nx || ny) {
        tex_draw_split(tile, surf, s0, t0, s0 + src_width, t0 + src_height, draw_cb_multi_rot, parms->filtering);    
    } else {
        tex_draw_split(tile, surf, s0, t0, s0 + src_width, t0 + src_height, draw_cb, parms->filtering);
    }
}

void rdpq_tex_blit(const surface_t *surf, float x0, float y0, const rdpq_blitparms_t *parms)
{
    static const rdpq_blitparms_t default_parms = {0};
    if (!parms) parms = &default_parms;

    // Check which implementation to use, depending on the requested features.
    if (F2I(parms->theta) == 0) {
        if (F2I(parms->scale_x) == 0 && F2I(parms->scale_y) == 0)
            tex_xblit_norotate_noscale(surf, x0, y0, parms);
            else
            tex_xblit_norotate(surf, x0, y0, parms);
    } else {
        tex_xblit(surf, x0, y0, parms);
    }
}

void rdpq_tex_load_tlut(uint16_t *tlut, int color_idx, int num_colors)
{
    rdpq_set_texture_image_raw(0, PhysicalAddr(tlut), FMT_RGBA16, num_colors, 1);
    rdpq_set_tile(RDPQ_TILE_INTERNAL, FMT_I4, TMEM_PALETTE_ADDR + color_idx*16*2*4, num_colors, 0);
    rdpq_load_tlut_raw(RDPQ_TILE_INTERNAL, color_idx, num_colors);
}
